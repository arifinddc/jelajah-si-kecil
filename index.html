<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Jelajah Si Kecil</title>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap');
        
        body, html { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; font-family: 'Fredoka', sans-serif; background: #0F172A; -webkit-tap-highlight-color: transparent; }
        #root { height: 100%; width: 100%; }

        .app-container {
            position: absolute; inset: 0; height: 100dvh; 
            display: flex; flex-direction: column;
            background: linear-gradient(180deg, #1E293B 0%, #0F172A 100%);
            max-width: 500px; margin: 0 auto;
            border-left: 2px solid #F59E0B; border-right: 2px solid #F59E0B;
            padding-top: env(safe-area-inset-top); padding-bottom: env(safe-area-inset-bottom);
        }

        .hud-bar { height: 55px; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; padding: 0 1rem; background: rgba(15, 23, 42, 0.95); border-bottom: 3px solid #F59E0B; z-index: 20; }
        .game-area { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding: 1rem; width: 100%; overflow-y: auto; }
        .instruction-text { font-size: 1.1rem; font-weight: 700; color: #F1F5F9; margin-bottom: 0.5rem; text-align: center; }

        /* MAZE STYLES */
        .maze-arrows-box { background: #334155; padding: 8px 12px; border-radius: 12px; margin-bottom: 15px; font-size: 1.6rem; border: 2px solid #64748b; color: #F59E0B; box-shadow: 0 4px 0 #1e293b; letter-spacing: 0.3rem; text-align: center; max-width: 95%; flex-wrap: wrap; display: flex; justify-content: center; gap: 5px; }
        .maze-grid { display: grid; gap: 4px; background: #1E293B; padding: 6px; border-radius: 16px; border: 3px solid #475569; margin-bottom: 1rem; }
        .maze-cell { width: 45px; height: 45px; background: #0F172A; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 1.4rem; color: #64748B; font-weight: bold; border: 1px solid #334155; position: relative; }
        .grid-4x4 .maze-cell { width: 40px; height: 40px; font-size: 1.2rem; }
        .grid-5x5 .maze-cell { width: 34px; height: 34px; font-size: 1rem; }
        .maze-cell.start { background: #F59E0B; color: white; border-color: #B45309; box-shadow: inset 0 0 10px rgba(0,0,0,0.2); z-index: 10; }

        /* --- BLOCK PUZZLE STYLES (UPDATED) --- */
        .block-target-grid {
            display: grid; gap: 2px; background: #1e293b; padding: 4px; border-radius: 8px; border: 3px solid #475569; margin-bottom: 20px;
        }
        .block-target-cell {
            width: 40px; height: 40px; border-radius: 4px; background: #0F172A; /* Kosong */
        }
        .block-target-cell.filled { background: #3B82F6; border: 1px solid #2563EB; } /* Terisi biru */
        .block-target-cell.locked { background: #475569; border: 1px solid #334155; opacity: 0.5; } /* Abu2 mati */
        .block-target-cell.hole { background: #0F172A; border: 2px dashed #F59E0B; opacity: 0.8; } /* Lubang target */

        /* Shape Preview di Tombol */
        .shape-preview { display: grid; gap: 2px; pointer-events: none; }
        .shape-cell { width: 12px; height: 12px; border-radius: 2px; }
        .shape-cell.active { background: #F59E0B; }
        .shape-cell.empty { background: transparent; }

        /* BUTTONS & UI */
        .option-grid { display: grid; gap: 10px; width: 100%; max-width: 360px; margin-top: auto; }
        .grid-cols-2 { grid-template-columns: repeat(2, 1fr); }
        .grid-cols-3 { grid-template-columns: repeat(3, 1fr); }
        
        .btn-choice {
            background: white; border: 3px solid #CBD5E1; border-radius: 1rem; 
            aspect-ratio: 1.3; display: flex; align-items: center; justify-content: center;
            font-size: 2rem; transition: transform 0.1s;
            box-shadow: 0 4px 0 #94A3B8; color: #0F172A; width: 100%; position: relative; overflow: hidden;
        }
        .btn-choice:active { transform: scale(0.95); box-shadow: 0 1px 0 #94A3B8; }
        .btn-choice.correct { background: #4ADE80; border-color: #166534; box-shadow: 0 4px 0 #166534; }
        .btn-choice.wrong { background: #F87171; border-color: #991B1B; box-shadow: 0 4px 0 #991B1B; opacity: 0.8; animation: shake 0.3s; }
        
        .game-card { background: #334155; border-radius: 16px; padding: 16px; margin-bottom: 20px; width: 100%; border: 2px solid #475569; box-shadow: 0 4px 0 #1e293b; display: flex; flex-direction: column; align-items: center; }
        .game-card-title { font-size: 1.4rem; font-weight: bold; color: white; margin-bottom: 10px; }
        .game-card-btn-group { display: flex; gap: 10px; width: 100%; }
        .menu-btn { flex: 1; background: #F59E0B; color: white; padding: 12px; border-radius: 12px; font-size: 1rem; font-weight: bold; box-shadow: 0 3px 0 #B45309; transition: all 0.1s; text-align: center; }
        .menu-btn:active { transform: translateY(2px); box-shadow: 0 1px 0 #B45309; }
        .menu-btn.secondary { background: #475569; box-shadow: 0 3px 0 #1e293b; }
        .menu-btn.disabled { opacity: 0.5; pointer-events: none; }
        .home-icon-btn { background: #334155; padding: 4px 8px; border-radius: 8px; font-size: 10px; font-weight: bold; color: #F59E0B; border: 1px solid #475569; }

        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // --- SHAPE DEFINITIONS (Tetris-like) ---
        // 1 = filled, 0 = empty. Grid 3x3 max for preview
        const SHAPES = {
            'O': [[1,1], [1,1]], // Kotak 2x2
            'I': [[1], [1], [1]], // Garis Vertikal 3
            'L': [[1,0], [1,0], [1,1]], // L shape
            'T': [[1,1,1], [0,1,0]], // T shape
            'Z': [[1,1,0], [0,1,1]], // Z shape
            'S': [[0,1,1], [1,1,0]], // S shape
            'dot': [[1]], // 1 dot
            'bar2': [[1,1]] // 2 bar horz
        };

        const App = () => {
            const [screen, setScreen] = useState('menu');
            const [activeGame, setActiveGame] = useState(null);
            
            const [userData, setUserData] = useState(() => {
                const saved = localStorage.getItem('jelajah_v23');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    if (!parsed.maze) return { lives: 3, lastLifeLost: null, maze: { level: 0, score: 0 }, block: { level: 0, score: 0 } };
                    return parsed;
                }
                return { lives: 3, lastLifeLost: null, maze: { level: 0, score: 0 }, block: { level: 0, score: 0 } };
            });

            const [puzzle, setPuzzle] = useState(null);
            const [feedback, setFeedback] = useState(null);
            const [wrongId, setWrongId] = useState(null);
            const [regenTimer, setRegenTimer] = useState("");

            useEffect(() => { localStorage.setItem('jelajah_v23', JSON.stringify(userData)); }, [userData]);

            useEffect(() => {
                const timer = setInterval(() => {
                    if (userData.lives < 3 && userData.lastLifeLost) {
                        const diff = Date.now() - userData.lastLifeLost;
                        if (diff >= 600000) setUserData(p => ({ ...p, lives: Math.min(p.lives + 1, 3), lastLifeLost: p.lives+1<3?Date.now():null }));
                        else setRegenTimer(`${Math.floor((600000-diff)/60000)}:${Math.floor(((600000-diff)%60000)/1000).toString().padStart(2,'0')}`);
                    } else setRegenTimer("");
                }, 1000);
                return () => clearInterval(timer);
            }, [userData]);

            // --- MAZE LOGIC ---
            const generateMaze = () => {
                const level = userData.maze.level;
                let gridSize = 3; let steps = 2; let optionCount = 2;
                if (level >= 5) { gridSize = 3; steps = 3; optionCount = 3; }
                if (level >= 10) { gridSize = 4; steps = 3; optionCount = 4; }
                if (level >= 20) { gridSize = 4; steps = 4; optionCount = 4; }
                if (level >= 30) { gridSize = 5; steps = 5; optionCount = 6; }

                const totalCells = gridSize * gridSize;
                const labels = "ABCDEFGHIJKLMNOPQRSTUVWXY".split("").slice(0, totalCells);
                const startPos = Math.floor(Math.random() * totalCells);
                
                let currentPos = startPos;
                let pathHistory = [startPos]; 
                let arrowSequence = [];

                for (let i = 0; i < steps; i++) {
                    let possibleMoves = [];
                    if ((currentPos + 1) % gridSize !== 0 && pathHistory[pathHistory.length-2] !== currentPos + 1) possibleMoves.push({ move: 1, icon: '‚û°Ô∏è' });
                    if (currentPos + gridSize < totalCells && pathHistory[pathHistory.length-2] !== currentPos + gridSize) possibleMoves.push({ move: gridSize, icon: '‚¨áÔ∏è' });
                    if (currentPos % gridSize !== 0 && pathHistory[pathHistory.length-2] !== currentPos - 1) possibleMoves.push({ move: -1, icon: '‚¨ÖÔ∏è' });
                    if (currentPos - gridSize >= 0 && pathHistory[pathHistory.length-2] !== currentPos - gridSize) possibleMoves.push({ move: -gridSize, icon: '‚¨ÜÔ∏è' });

                    if (possibleMoves.length === 0) break;
                    const selected = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    currentPos += selected.move;
                    pathHistory.push(currentPos);
                    arrowSequence.push(selected.icon);
                }

                const targetLabel = labels[currentPos];
                const targetOption = { id: `pos_${currentPos}`, icon: targetLabel, isTarget: true };
                const otherIndices = Array.from({length: totalCells}, (_, i) => i).filter(i => i !== currentPos);
                const randomWrong = otherIndices.sort(() => 0.5 - Math.random()).slice(0, optionCount - 1);
                const wrongOptions = randomWrong.map(idx => ({ id: `pos_${idx}`, icon: labels[idx], isTarget: false }));

                setPuzzle({
                    gameType: 'maze',
                    gridSize: gridSize,
                    labels: labels,
                    arrows: arrowSequence,
                    options: [targetOption, ...wrongOptions].sort(() => 0.5 - Math.random()),
                    targetId: targetOption.id,
                    startIndex: startPos,
                    instruction: "Ikuti panah! Dimana Kucing sekarang?"
                });
            };

            // --- BLOCK PUZZLE LOGIC (REAL TETRIS STYLE) ---
            const generateBlock = () => {
                const level = userData.block.level;
                // Tentukan ukuran grid: 3x3, 4x4, 5x5
                let gridSize = 3; 
                let lockedCount = 1; // Jumlah blok mati
                let optionCount = 2;
                
                if (level >= 5) { gridSize = 4; lockedCount = 2; optionCount = 3; }
                if (level >= 15) { gridSize = 4; lockedCount = 4; optionCount = 4; }
                
                const totalCells = gridSize * gridSize;
                let gridState = Array(totalCells).fill('filled'); // Default semua terisi biru

                // 1. Buat Hole (Target Shape)
                // Kita ambil random shape dari SHAPES
                const shapeKeys = Object.keys(SHAPES);
                const targetShapeKey = shapeKeys[Math.floor(Math.random() * shapeKeys.length)];
                const targetMatrix = SHAPES[targetShapeKey]; // [[1,1], [1,0]]
                
                // Cari posisi random di grid yang muat shape ini
                const shapeH = targetMatrix.length;
                const shapeW = targetMatrix[0].length;
                
                const maxR = gridSize - shapeH;
                const maxC = gridSize - shapeW;
                
                const startR = Math.floor(Math.random() * (maxR + 1));
                const startC = Math.floor(Math.random() * (maxC + 1));
                
                // Bolongi grid sesuai shape (tandai sebagai 'hole')
                for(let r=0; r<shapeH; r++){
                    for(let c=0; c<shapeW; c++){
                        if(targetMatrix[r][c] === 1) {
                            const gridIdx = (startR + r) * gridSize + (startC + c);
                            gridState[gridIdx] = 'hole';
                        }
                    }
                }

                // 2. Tambah Locked Blocks (Pengganggu)
                // Cari sel yg masih 'filled' (biru), ubah jadi 'locked' (abu)
                let availableForLock = gridState.map((s, i) => s === 'filled' ? i : -1).filter(i => i !== -1);
                
                for(let i=0; i<lockedCount; i++){
                    if(availableForLock.length === 0) break;
                    const randIdx = Math.floor(Math.random() * availableForLock.length);
                    const gridIdx = availableForLock[randIdx];
                    gridState[gridIdx] = 'locked';
                    availableForLock.splice(randIdx, 1);
                }

                // 3. Generate Options
                const targetOption = { id: 'correct', shapeMatrix: targetMatrix, isTarget: true };
                
                // Wrong options: Ambil shape lain yang beda
                const wrongShapes = shapeKeys.filter(k => k !== targetShapeKey);
                const wrongOpts = wrongShapes.sort(()=>0.5-Math.random()).slice(0, optionCount - 1).map((k, i) => ({
                    id: `wrong_${i}`, shapeMatrix: SHAPES[k], isTarget: false
                }));

                setPuzzle({
                    gameType: 'block',
                    gridSize: gridSize,
                    gridState: gridState, // Array status sel
                    options: [targetOption, ...wrongOpts].sort(() => 0.5 - Math.random()),
                    targetId: 'correct',
                    instruction: "Pasang blok yang cocok!"
                });
            };

            // --- CONTROLLERS ---
            const startGame = (type, mode) => {
                setActiveGame(type);
                if (mode === 'new') {
                    setUserData(p => ({ ...p, lives: 3, [type]: { level: 0, score: 0 } }));
                }
                setScreen('game');
                setTimeout(() => {
                    if (type === 'maze') generateMaze();
                    else generateBlock();
                }, 50);
            };

            const nextLevel = () => {
                if (activeGame === 'maze') generateMaze();
                else generateBlock();
            };

            const handleAnswer = (opt) => {
                if (feedback === 'correct') return;

                if (opt.isTarget) {
                    setFeedback('correct');
                    setWrongId(null);
                    setTimeout(() => {
                        setUserData(p => ({
                            ...p,
                            [activeGame]: {
                                level: p[activeGame].level + 1,
                                score: p[activeGame].score + 10
                            }
                        }));
                        setScreen('result'); setFeedback(null);
                    }, 500);
                } else {
                    setWrongId(opt.id);
                    setUserData(p => ({ ...p, lives: Math.max(0, p.lives-1), lastLifeLost: p.lives===3?Date.now():p.lastLifeLost }));
                    setTimeout(() => setWrongId(null), 500);
                }
            };

            // --- RENDER HELPERS ---
            const renderShapePreview = (matrix) => {
                const rows = matrix.length;
                const cols = matrix[0].length;
                return (
                    <div className="shape-preview" style={{gridTemplateColumns: `repeat(${cols}, 1fr)`}}>
                        {matrix.flat().map((cell, i) => (
                            <div key={i} className={`shape-cell ${cell===1?'active':'empty'}`} />
                        ))}
                    </div>
                );
            };

            const renderMenu = () => (
                <div className="app-container p-6 justify-start overflow-y-auto">
                    <div className="text-center mt-4 mb-8">
                        <div className="text-6xl mb-2">üß©</div>
                        <h1 className="text-2xl font-black text-white uppercase">Jelajah Si Kecil</h1>
                        <p className="text-amber-500 font-bold text-xs uppercase tracking-widest">v23.0 - True Blocks</p>
                        <div className="text-slate-400 text-xs mt-2">Energi: {userData.lives}/3 {regenTimer && `(${regenTimer})`}</div>
                    </div>

                    <div className="game-card">
                        <div className="game-card-title">üß≠ Labirin Panah</div>
                        <div className="text-slate-400 text-xs mb-4">Level {userData.maze.level + 1} ‚Ä¢ Skor {userData.maze.score}</div>
                        <div className="game-card-btn-group">
                            <button onClick={() => startGame('maze', 'new')} className="menu-btn">MULAI BARU</button>
                            <button onClick={() => startGame('maze', 'continue')} className={`menu-btn secondary ${userData.maze.level===0?'disabled':''}`}>LANJUT</button>
                        </div>
                    </div>

                    <div className="game-card">
                        <div className="game-card-title">üî≤ Blok Puzzle</div>
                        <div className="text-slate-400 text-xs mb-4">Level {userData.block.level + 1} ‚Ä¢ Skor {userData.block.score}</div>
                        <div className="game-card-btn-group">
                            <button onClick={() => startGame('block', 'new')} className="menu-btn">MULAI BARU</button>
                            <button onClick={() => startGame('block', 'continue')} className={`menu-btn secondary ${userData.block.level===0?'disabled':''}`}>LANJUT</button>
                        </div>
                    </div>
                </div>
            );

            const renderGame = () => (
                <div className="app-container">
                    <div className="hud-bar">
                        <div className="flex flex-col items-center"><span className="text-xl">‚ù§Ô∏è {userData.lives}</span><span className="text-[9px] text-amber-500">{regenTimer}</span></div>
                        <div className="flex flex-col items-center">
                            <span className="text-[10px] text-slate-400 font-bold uppercase">{activeGame === 'maze' ? 'Labirin' : 'Blok'} Lv {userData[activeGame].level + 1}</span>
                            <button onClick={() => setScreen('menu')} className="home-icon-btn mt-1">üè† MENU</button>
                        </div>
                        <div className="bg-amber-500 text-white px-3 py-1 rounded-full font-bold text-sm">‚≠ê {userData[activeGame].score}</div>
                    </div>

                    <div className="game-area">
                        {userData.lives <= 0 ? (
                            <div className="text-center mt-20"><h2 className="text-xl text-white font-bold mb-4">Energi Habis!</h2><button onClick={() => setScreen('menu')} className="menu-btn">Kembali</button></div>
                        ) : puzzle ? (
                            <div className="w-full flex flex-col items-center h-full">
                                <h2 className="instruction-text">{puzzle.instruction}</h2>
                                
                                <div className="flex-1 flex flex-col items-center justify-center w-full">
                                    {puzzle.gameType === 'maze' && (
                                        <>
                                            <div className="maze-arrows-box">{puzzle.arrows.map((a, i) => <span key={i}>{a}</span>)}</div>
                                            <div className={`maze-grid grid-${puzzle.gridSize}`} style={{gridTemplateColumns: `repeat(${puzzle.gridSize}, 1fr)`}}>
                                                {puzzle.labels.map((l, i) => (
                                                    <div key={i} className={`maze-cell ${i===puzzle.startIndex ? 'start' : ''} ${puzzle.gridSize===4?'text-sm':''} ${puzzle.gridSize===5?'text-xs':''}`}>
                                                        {i===puzzle.startIndex ? 'üê±' : l}
                                                    </div>
                                                ))}
                                            </div>
                                        </>
                                    )}

                                    {puzzle.gameType === 'block' && (
                                        <div className="block-target-grid" style={{gridTemplateColumns: `repeat(${puzzle.gridSize}, 1fr)`}}>
                                            {puzzle.gridState.map((status, i) => (
                                                <div key={i} className={`block-target-cell ${status}`}>
                                                    {status === 'hole' ? '?' : ''}
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>

                                <div className={`option-grid ${puzzle.options.length > 4 ? 'grid-cols-3' : 'grid-cols-2'}`}>
                                    {puzzle.options.map((opt, i) => (
                                        <button key={i} onClick={() => handleAnswer(opt)} 
                                            className={`btn-choice ${feedback==='correct' && opt.isTarget ? 'correct' : ''} ${wrongId === opt.id ? 'wrong' : ''}`}>
                                            {puzzle.gameType === 'maze' ? opt.icon : renderShapePreview(opt.shapeMatrix)}
                                        </button>
                                    ))}
                                </div>
                            </div>
                        ) : null}
                    </div>
                </div>
            );

            if (screen === 'menu') return renderMenu();
            if (screen === 'result') return (
                <div className="app-container p-6 justify-center items-center text-center bg-slate-900">
                    <div className="text-7xl mb-4">üåü</div>
                    <h2 className="text-2xl font-bold text-white mb-6">Hebat!</h2>
                    {/* BUTTON FIX SIZE */}
                    <button onClick={() => { setScreen('game'); nextLevel(); }} className="menu-btn bg-green-600 w-full max-w-[200px] py-3 text-lg">LANJUT LEVEL</button>
                    <button onClick={() => setScreen('menu')} className="text-slate-500 font-bold mt-4 uppercase text-xs">Ke Menu Utama</button>
                </div>
            );

            return renderGame();
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
