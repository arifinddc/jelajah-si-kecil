<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Jelajah Si Kecil</title>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap');
        
        body, html { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; font-family: 'Fredoka', sans-serif; background: #0F172A; -webkit-tap-highlight-color: transparent; }
        #root { height: 100%; width: 100%; }

        .app-container {
            position: absolute; inset: 0; height: 100dvh; 
            display: flex; flex-direction: column;
            background: linear-gradient(180deg, #1E293B 0%, #0F172A 100%);
            max-width: 500px; margin: 0 auto;
            border-left: 2px solid #F59E0B; border-right: 2px solid #F59E0B;
            padding-top: env(safe-area-inset-top); padding-bottom: env(safe-area-inset-bottom);
        }

        .hud-bar { height: 55px; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; padding: 0 1rem; background: rgba(15, 23, 42, 0.95); border-bottom: 3px solid #F59E0B; z-index: 20; }
        .game-area { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding: 1rem; width: 100%; overflow-y: auto; }
        .instruction-text { font-size: 1.1rem; font-weight: 700; color: #F1F5F9; margin-bottom: 0.5rem; text-align: center; }

        /* MAZE STYLES */
        .maze-arrows-box { background: #334155; padding: 8px 12px; border-radius: 12px; margin-bottom: 15px; font-size: 1.6rem; border: 2px solid #64748b; color: #F59E0B; box-shadow: 0 4px 0 #1e293b; letter-spacing: 0.3rem; text-align: center; max-width: 95%; flex-wrap: wrap; display: flex; justify-content: center; gap: 5px; }
        .maze-grid { display: grid; gap: 4px; background: #1E293B; padding: 6px; border-radius: 16px; border: 3px solid #475569; margin-bottom: 1rem; }
        .maze-cell { width: 45px; height: 45px; background: #0F172A; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 1.4rem; color: #64748B; font-weight: bold; border: 1px solid #334155; position: relative; }
        .grid-4x4 .maze-cell { width: 40px; height: 40px; font-size: 1.2rem; }
        .grid-5x5 .maze-cell { width: 34px; height: 34px; font-size: 1rem; }
        .maze-cell.start { background: #F59E0B; color: white; border-color: #B45309; box-shadow: inset 0 0 10px rgba(0,0,0,0.2); z-index: 10; }

        /* BLOCK PUZZLE STYLES */
        .block-target-grid { display: grid; gap: 3px; background: #1e293b; padding: 5px; border-radius: 12px; border: 3px solid #475569; margin-bottom: 20px; }
        .block-target-cell { width: 45px; height: 45px; border-radius: 6px; }
        .block-target-cell.filled { border: 1px solid rgba(255,255,255,0.2); }
        .block-target-cell.locked { background: #475569; border: 1px solid #334155; opacity: 0.4; } 
        .block-target-cell.hole { background: #0F172A; border: 2px dashed #475569; box-shadow: inset 0 0 5px black; }
        .mini-grid { display: grid; gap: 2px; pointer-events: none; }
        .mini-cell { width: 14px; height: 14px; border-radius: 2px; }
        .mini-cell.active { background: #F59E0B; box-shadow: inset 0 0 2px rgba(255,255,255,0.5); }
        .mini-cell.empty { background: transparent; }

        /* --- MEMORY GAME STYLES (NEW) --- */
        .memory-shelf {
            display: flex; flex-wrap: wrap; justify-content: center; gap: 10px;
            background: #1e293b; padding: 20px; border-radius: 16px; border: 3px solid #475569;
            margin-bottom: 10px; min-height: 150px; width: 100%; max-width: 320px;
        }
        .memory-item {
            width: 60px; height: 60px; background: #0F172A; border-radius: 12px;
            display: flex; align-items: center; justify-content: center; font-size: 2.5rem;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .timer-bar-container {
            width: 100%; max-width: 320px; height: 8px; background: #334155;
            border-radius: 4px; overflow: hidden; margin-bottom: 20px;
        }
        .timer-bar-fill {
            height: 100%; background: #F59E0B; transition: width linear;
        }
        @keyframes popIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        /* UI ELEMENTS */
        .option-grid { display: grid; gap: 10px; width: 100%; max-width: 360px; margin-top: auto; }
        .grid-cols-2 { grid-template-columns: repeat(2, 1fr); }
        .grid-cols-3 { grid-template-columns: repeat(3, 1fr); }
        
        .btn-choice {
            background: white; border: 3px solid #CBD5E1; border-radius: 1rem; 
            aspect-ratio: 1.3; display: flex; align-items: center; justify-content: center;
            font-size: 2rem; transition: transform 0.1s;
            box-shadow: 0 4px 0 #94A3B8; color: #0F172A; width: 100%; position: relative; overflow: hidden;
        }
        .btn-choice:active { transform: scale(0.95); box-shadow: 0 1px 0 #94A3B8; }
        .btn-choice.correct { background: #4ADE80; border-color: #166534; box-shadow: 0 4px 0 #166534; }
        .btn-choice.wrong { background: #F87171; border-color: #991B1B; box-shadow: 0 4px 0 #991B1B; opacity: 0.8; animation: shake 0.3s; }
        
        .game-card { background: #334155; border-radius: 16px; padding: 16px; margin-bottom: 20px; width: 100%; border: 2px solid #475569; box-shadow: 0 4px 0 #1e293b; display: flex; flex-direction: column; align-items: center; }
        .game-card-title { font-size: 1.4rem; font-weight: bold; color: white; margin-bottom: 10px; }
        .game-card-btn-group { display: flex; gap: 10px; width: 100%; }
        .menu-btn { flex: 1; background: #F59E0B; color: white; padding: 12px; border-radius: 12px; font-size: 1rem; font-weight: bold; box-shadow: 0 3px 0 #B45309; transition: all 0.1s; text-align: center; }
        .menu-btn:active { transform: translateY(2px); box-shadow: 0 1px 0 #B45309; }
        .menu-btn.secondary { background: #475569; box-shadow: 0 3px 0 #1e293b; }
        .menu-btn.disabled { opacity: 0.5; pointer-events: none; }
        .home-icon-btn { background: #334155; padding: 4px 8px; border-radius: 8px; font-size: 10px; font-weight: bold; color: #F59E0B; border: 1px solid #475569; }

        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const BLOCK_PATTERNS = [
            'linear-gradient(135deg, #3B82F6, #2563EB)', 
            'linear-gradient(135deg, #EF4444, #DC2626)', 
            'linear-gradient(135deg, #10B981, #059669)', 
            'linear-gradient(135deg, #F59E0B, #D97706)', 
            'linear-gradient(135deg, #8B5CF6, #7C3AED)'
        ];

        // Emojis for Memory Game
        const MEMORY_EMOJIS = ["üê±", "üê∂", "ü¶Å", "üê∏", "üêµ", "üçé", "üçå", "üçá", "üçâ", "üçì", "üöó", "üöÄ", "‚öΩ", "üèÄ", "üçï", "üçî", "üç¶", "üéà", "üéÅ", "‚è∞"];

        const App = () => {
            const [screen, setScreen] = useState('menu');
            const [activeGame, setActiveGame] = useState(null);
            
            // USER DATA with Memory
            const [userData, setUserData] = useState(() => {
                const saved = localStorage.getItem('jelajah_v25');
                const defaultData = { 
                    lives: 3, lastLifeLost: null, 
                    maze: { level: 0, score: 0 }, 
                    block: { level: 0, score: 0 },
                    memory: { level: 0, score: 0 } // NEW
                };
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Merge if memory is missing in old save
                    return { ...defaultData, ...parsed };
                }
                return defaultData;
            });

            const [puzzle, setPuzzle] = useState(null);
            const [feedback, setFeedback] = useState(null);
            const [wrongId, setWrongId] = useState(null);
            const [regenTimer, setRegenTimer] = useState("");
            const [memTimer, setMemTimer] = useState(100); // For progress bar

            useEffect(() => { localStorage.setItem('jelajah_v25', JSON.stringify(userData)); }, [userData]);

            // Regen System
            useEffect(() => {
                const timer = setInterval(() => {
                    if (userData.lives < 3 && userData.lastLifeLost) {
                        const diff = Date.now() - userData.lastLifeLost;
                        if (diff >= 600000) setUserData(p => ({ ...p, lives: Math.min(p.lives + 1, 3), lastLifeLost: p.lives+1<3?Date.now():null }));
                        else setRegenTimer(`${Math.floor((600000-diff)/60000)}:${Math.floor(((600000-diff)%60000)/1000).toString().padStart(2,'0')}`);
                    } else setRegenTimer("");
                }, 1000);
                return () => clearInterval(timer);
            }, [userData]);

            // Memory Timer System
            useEffect(() => {
                if (activeGame === 'memory' && puzzle && puzzle.phase === 'memorize') {
                    const duration = puzzle.duration * 1000;
                    const interval = 50; 
                    const step = 100 / (duration / interval);
                    
                    const t = setInterval(() => {
                        setMemTimer(prev => {
                            if (prev <= 0) {
                                clearInterval(t);
                                // Switch to Question Phase
                                setPuzzle(p => ({ ...p, phase: 'question', instruction: "Mana benda yang tadi ada?" }));
                                return 0;
                            }
                            return prev - step;
                        });
                    }, interval);
                    return () => clearInterval(t);
                }
            }, [puzzle, activeGame]);


            // --- GAME LOGIC GENERATORS ---

            const generateMaze = () => {
                const level = userData.maze.level;
                let gridSize = 3; let steps = 2; let optionCount = 2;
                if (level >= 5) { gridSize = 3; steps = 3; optionCount = 3; }
                if (level >= 10) { gridSize = 4; steps = 3; optionCount = 4; }
                if (level >= 20) { gridSize = 4; steps = 4; optionCount = 4; }
                if (level >= 30) { gridSize = 5; steps = 5; optionCount = 6; }

                const totalCells = gridSize * gridSize;
                const labels = "ABCDEFGHIJKLMNOPQRSTUVWXY".split("").slice(0, totalCells);
                const startPos = Math.floor(Math.random() * totalCells);
                
                let currentPos = startPos;
                let pathHistory = [startPos]; 
                let arrowSequence = [];

                for (let i = 0; i < steps; i++) {
                    let possibleMoves = [];
                    if ((currentPos + 1) % gridSize !== 0 && pathHistory[pathHistory.length-2] !== currentPos + 1) possibleMoves.push({ move: 1, icon: '‚û°Ô∏è' });
                    if (currentPos + gridSize < totalCells && pathHistory[pathHistory.length-2] !== currentPos + gridSize) possibleMoves.push({ move: gridSize, icon: '‚¨áÔ∏è' });
                    if (currentPos % gridSize !== 0 && pathHistory[pathHistory.length-2] !== currentPos - 1) possibleMoves.push({ move: -1, icon: '‚¨ÖÔ∏è' });
                    if (currentPos - gridSize >= 0 && pathHistory[pathHistory.length-2] !== currentPos - gridSize) possibleMoves.push({ move: -gridSize, icon: '‚¨ÜÔ∏è' });

                    if (possibleMoves.length === 0) break;
                    const selected = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    currentPos += selected.move;
                    pathHistory.push(currentPos);
                    arrowSequence.push(selected.icon);
                }

                const targetLabel = labels[currentPos];
                const targetOption = { id: `pos_${currentPos}`, icon: targetLabel, isTarget: true };
                const otherIndices = Array.from({length: totalCells}, (_, i) => i).filter(i => i !== currentPos);
                const randomWrong = otherIndices.sort(() => 0.5 - Math.random()).slice(0, optionCount - 1);
                const wrongOptions = randomWrong.map(idx => ({ id: `pos_${idx}`, icon: labels[idx], isTarget: false }));

                setPuzzle({
                    gameType: 'maze',
                    gridSize: gridSize,
                    labels: labels,
                    arrows: arrowSequence,
                    options: [targetOption, ...wrongOptions].sort(() => 0.5 - Math.random()),
                    targetId: targetOption.id,
                    startIndex: startPos,
                    instruction: "Ikuti panah! Dimana Kucing sekarang?"
                });
            };

            const generateBlock = () => {
                const level = userData.block.level;
                let gridSize = 3; let missingCount = 2; let isScattered = false; let optionCount = 2; let lockedCount = 0;
                if (level >= 5) { gridSize = 4; missingCount = 3; lockedCount = 1; optionCount = 3; }
                if (level >= 10) { gridSize = 4; missingCount = 3; lockedCount = 2; optionCount = 4; isScattered = true; }
                if (level >= 20) { gridSize = 4; missingCount = 4; lockedCount = 3; optionCount = 4; isScattered = true; }

                const totalCells = gridSize * gridSize;
                const mainPattern = BLOCK_PATTERNS[Math.floor(Math.random() * BLOCK_PATTERNS.length)];

                let missingIndices = [];
                let startIdx = Math.floor(Math.random() * totalCells);
                missingIndices.push(startIdx);

                while(missingIndices.length < missingCount) {
                    if (isScattered) {
                        let nextIdx = Math.floor(Math.random() * totalCells);
                        if (!missingIndices.includes(nextIdx)) missingIndices.push(nextIdx);
                    } else {
                        let lastIdx = missingIndices[missingIndices.length-1];
                        let neighbors = [];
                        if ((lastIdx + 1) % gridSize !== 0) neighbors.push(lastIdx + 1);
                        if (lastIdx % gridSize !== 0) neighbors.push(lastIdx - 1);
                        if (lastIdx + gridSize < totalCells) neighbors.push(lastIdx + gridSize);
                        if (lastIdx - gridSize >= 0) neighbors.push(lastIdx - gridSize);
                        let nextIdx = neighbors[Math.floor(Math.random() * neighbors.length)];
                        if (!missingIndices.includes(nextIdx)) missingIndices.push(nextIdx);
                    }
                }
                missingIndices.sort((a,b) => a-b);

                let lockedIndices = [];
                let safeIndices = Array.from({length: totalCells}, (_,i) => i).filter(i => !missingIndices.includes(i));
                for(let i=0; i<lockedCount; i++){
                    if (safeIndices.length === 0) break;
                    let pick = Math.floor(Math.random() * safeIndices.length);
                    lockedIndices.push(safeIndices[pick]);
                    safeIndices.splice(pick, 1);
                }

                let gridState = Array(totalCells).fill('filled');
                missingIndices.forEach(i => gridState[i] = 'hole');
                lockedIndices.forEach(i => gridState[i] = 'locked');

                const targetOption = { id: 'correct', indices: [...missingIndices], isTarget: true };
                const wrongOpts = [];
                for (let i=0; i < optionCount - 1; i++) {
                    let fakeIndices = [...missingIndices];
                    if (Math.random() > 0.5 && fakeIndices.length > 0) fakeIndices[0] = (fakeIndices[0] + 1) % totalCells;
                    else {
                        if (fakeIndices.length > 1) fakeIndices.pop();
                        else {
                             let r = Math.floor(Math.random() * totalCells);
                             if (!fakeIndices.includes(r)) fakeIndices.push(r);
                        }
                    }
                    wrongOpts.push({ id: `wrong_${i}`, indices: fakeIndices, isTarget: false });
                }

                setPuzzle({
                    gameType: 'block',
                    gridSize: gridSize,
                    gridState: gridState,
                    gridPattern: mainPattern,
                    options: [targetOption, ...wrongOpts].sort(() => 0.5 - Math.random()),
                    targetId: 'correct',
                    instruction: "Pasang blok yang cocok!"
                });
            };

            const generateMemory = () => {
                const level = userData.memory.level;
                // Config
                let itemCount = 3; let duration = 5; let optionCount = 2;
                if (level >= 5) { itemCount = 4; duration = 4; optionCount = 3; }
                if (level >= 15) { itemCount = 5; duration = 3; optionCount = 4; }
                if (level >= 25) { itemCount = 6; duration = 3; optionCount = 4; }

                // Pick items to show
                const shuffledPool = [...MEMORY_EMOJIS].sort(() => 0.5 - Math.random());
                const shownItems = shuffledPool.slice(0, itemCount);
                
                // Pick target (one of the shown items)
                const targetItem = shownItems[Math.floor(Math.random() * shownItems.length)];
                
                // Pick distractors (items NOT shown)
                const notShown = shuffledPool.slice(itemCount); // Items that were not picked
                const distractors = notShown.slice(0, optionCount - 1);
                
                const options = [
                    { id: 'correct', icon: targetItem, isTarget: true },
                    ...distractors.map((item, i) => ({ id: `wrong_${i}`, icon: item, isTarget: false }))
                ];

                setMemTimer(100); // Reset Timer
                setPuzzle({
                    gameType: 'memory',
                    phase: 'memorize', // memorize -> question
                    items: shownItems,
                    duration: duration,
                    options: options.sort(() => 0.5 - Math.random()),
                    targetId: 'correct',
                    instruction: "Hafalkan benda ini!"
                });
            };

            // --- CONTROLLERS ---
            const startGame = (type, mode) => {
                setActiveGame(type);
                if (mode === 'new') {
                    setUserData(p => ({ ...p, lives: 3, [type]: { level: 0, score: 0 } }));
                }
                setScreen('game');
                setTimeout(() => {
                    if (type === 'maze') generateMaze();
                    else if (type === 'block') generateBlock();
                    else generateMemory();
                }, 50);
            };

            const nextLevel = () => {
                if (activeGame === 'maze') generateMaze();
                else if (activeGame === 'block') generateBlock();
                else generateMemory();
            };

            const handleAnswer = (opt) => {
                if (feedback === 'correct') return;

                if (opt.isTarget) {
                    setFeedback('correct');
                    setWrongId(null);
                    setTimeout(() => {
                        setUserData(p => ({
                            ...p,
                            [activeGame]: {
                                level: p[activeGame].level + 1,
                                score: p[activeGame].score + 10
                            }
                        }));
                        setScreen('result'); setFeedback(null);
                    }, 500);
                } else {
                    setWrongId(opt.id);
                    setUserData(p => ({ ...p, lives: Math.max(0, p.lives-1), lastLifeLost: p.lives===3?Date.now():p.lastLifeLost }));
                    setTimeout(() => setWrongId(null), 500);
                }
            };

            const renderOptionGrid = (indices, gridSize, pattern) => {
                const displaySize = gridSize; 
                const cells = Array(displaySize * displaySize).fill(0);
                indices.forEach(idx => { if (idx < cells.length) cells[idx] = 1; });
                return (
                    <div className="mini-grid" style={{gridTemplateColumns: `repeat(${displaySize}, 1fr)`}}>
                        {cells.map((val, i) => (
                            <div key={i} className={`mini-cell ${val===1 ? 'active' : 'empty'}`} 
                                 style={{background: val===1 ? pattern : 'transparent'}}></div>
                        ))}
                    </div>
                );
            };

            const renderMenu = () => (
                <div className="app-container p-6 justify-start overflow-y-auto">
                    <div className="text-center mt-4 mb-8">
                        <div className="text-6xl mb-2">üß©</div>
                        <h1 className="text-2xl font-black text-white uppercase">Jelajah Si Kecil</h1>
                        <p className="text-amber-500 font-bold text-xs uppercase tracking-widest">v25.0 - Toko Ingatan</p>
                        <div className="text-slate-400 text-xs mt-2">Energi: {userData.lives}/3 {regenTimer && `(${regenTimer})`}</div>
                    </div>

                    <div className="game-card">
                        <div className="game-card-title">üß≠ Labirin Panah</div>
                        <div className="text-slate-400 text-xs mb-4">Level {userData.maze.level + 1} ‚Ä¢ Skor {userData.maze.score}</div>
                        <div className="game-card-btn-group">
                            <button onClick={() => startGame('maze', 'new')} className="menu-btn">MULAI BARU</button>
                            <button onClick={() => startGame('maze', 'continue')} className={`menu-btn secondary ${userData.maze.level===0?'disabled':''}`}>LANJUT</button>
                        </div>
                    </div>

                    <div className="game-card">
                        <div className="game-card-title">üî≤ Blok Puzzle</div>
                        <div className="text-slate-400 text-xs mb-4">Level {userData.block.level + 1} ‚Ä¢ Skor {userData.block.score}</div>
                        <div className="game-card-btn-group">
                            <button onClick={() => startGame('block', 'new')} className="menu-btn">MULAI BARU</button>
                            <button onClick={() => startGame('block', 'continue')} className={`menu-btn secondary ${userData.block.level===0?'disabled':''}`}>LANJUT</button>
                        </div>
                    </div>

                    {/* NEW CARD: MEMORY */}
                    <div className="game-card">
                        <div className="game-card-title">üì¶ Toko Ingatan</div>
                        <div className="text-slate-400 text-xs mb-4">Level {userData.memory.level + 1} ‚Ä¢ Skor {userData.memory.score}</div>
                        <div className="game-card-btn-group">
                            <button onClick={() => startGame('memory', 'new')} className="menu-btn">MULAI BARU</button>
                            <button onClick={() => startGame('memory', 'continue')} className={`menu-btn secondary ${userData.memory.level===0?'disabled':''}`}>LANJUT</button>
                        </div>
                    </div>
                </div>
            );

            const renderGame = () => {
                let gameTitle = '';
                if(activeGame === 'maze') gameTitle = 'Labirin';
                else if(activeGame === 'block') gameTitle = 'Blok';
                else gameTitle = 'Ingatan';

                return (
                    <div className="app-container">
                        <div className="hud-bar">
                            <div className="flex flex-col items-center"><span className="text-xl">‚ù§Ô∏è {userData.lives}</span><span className="text-[9px] text-amber-500">{regenTimer}</span></div>
                            <div className="flex flex-col items-center">
                                <span className="text-[10px] text-slate-400 font-bold uppercase">{gameTitle} Lv {userData[activeGame].level + 1}</span>
                                <button onClick={() => setScreen('menu')} className="home-icon-btn mt-1">üè† MENU</button>
                            </div>
                            <div className="bg-amber-500 text-white px-3 py-1 rounded-full font-bold text-sm">‚≠ê {userData[activeGame].score}</div>
                        </div>

                        <div className="game-area">
                            {userData.lives <= 0 ? (
                                <div className="text-center mt-20"><h2 className="text-xl text-white font-bold mb-4">Energi Habis!</h2><button onClick={() => setScreen('menu')} className="menu-btn">Kembali</button></div>
                            ) : puzzle ? (
                                <div className="w-full flex flex-col items-center h-full">
                                    <h2 className="instruction-text">{puzzle.instruction}</h2>
                                    
                                    <div className="flex-1 flex flex-col items-center justify-center w-full">
                                        {/* MAZE */}
                                        {puzzle.gameType === 'maze' && (
                                            <>
                                                <div className="maze-arrows-box">{puzzle.arrows.map((a, i) => <span key={i}>{a}</span>)}</div>
                                                <div className={`maze-grid grid-${puzzle.gridSize}`} style={{gridTemplateColumns: `repeat(${puzzle.gridSize}, 1fr)`}}>
                                                    {puzzle.labels.map((l, i) => (
                                                        <div key={i} className={`maze-cell ${i===puzzle.startIndex ? 'start' : ''} ${puzzle.gridSize===4?'text-sm':''} ${puzzle.gridSize===5?'text-xs':''}`}>
                                                            {i===puzzle.startIndex ? 'üê±' : l}
                                                        </div>
                                                    ))}
                                                </div>
                                            </>
                                        )}

                                        {/* BLOCK */}
                                        {puzzle.gameType === 'block' && (
                                            <div className="block-target-grid" style={{gridTemplateColumns: `repeat(${puzzle.gridSize}, 1fr)`}}>
                                                {puzzle.gridState.map((status, i) => (
                                                    <div key={i} className={`block-target-cell ${status}`} style={{background: status === 'filled' ? puzzle.gridPattern : ''}}></div>
                                                ))}
                                            </div>
                                        )}

                                        {/* MEMORY */}
                                        {puzzle.gameType === 'memory' && (
                                            <>
                                                {puzzle.phase === 'memorize' ? (
                                                    <div className="w-full flex flex-col items-center">
                                                        <div className="memory-shelf">
                                                            {puzzle.items.map((item, i) => (
                                                                <div key={i} className="memory-item">{item}</div>
                                                            ))}
                                                        </div>
                                                        <div className="timer-bar-container">
                                                            <div className="timer-bar-fill" style={{width: `${memTimer}%`}}></div>
                                                        </div>
                                                    </div>
                                                ) : (
                                                    <div className="memory-shelf flex items-center justify-center">
                                                        <span className="text-4xl">‚ùì</span>
                                                    </div>
                                                )}
                                            </>
                                        )}
                                    </div>

                                    {/* OPTIONS (Hide if Memory Phase is Memorize) */}
                                    {!(puzzle.gameType === 'memory' && puzzle.phase === 'memorize') && (
                                        <div className={`option-grid ${puzzle.options.length > 4 ? 'grid-cols-3' : 'grid-cols-2'}`}>
                                            {puzzle.options.map((opt, i) => (
                                                <button key={i} onClick={() => handleAnswer(opt)} 
                                                    className={`btn-choice ${feedback==='correct' && opt.isTarget ? 'correct' : ''} ${wrongId === opt.id ? 'wrong' : ''}`}>
                                                    {puzzle.gameType === 'maze' ? opt.icon : 
                                                     puzzle.gameType === 'block' ? renderOptionGrid(opt.indices, puzzle.gridSize, puzzle.gridPattern) :
                                                     opt.icon}
                                                </button>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            ) : null}
                        </div>
                    </div>
                );
            };

            if (screen === 'menu') return renderMenu();
            if (screen === 'result') return (
                <div className="app-container p-6 justify-center items-center text-center bg-slate-900">
                    <div className="text-7xl mb-4">üåü</div>
                    <h2 className="text-2xl font-bold text-white mb-6">Hebat!</h2>
                    <button onClick={() => { setScreen('game'); nextLevel(); }} className="menu-btn bg-green-600 w-full max-w-[200px] py-3 text-lg">LANJUT LEVEL</button>
                    <button onClick={() => setScreen('menu')} className="text-slate-500 font-bold mt-4 uppercase text-xs">Ke Menu Utama</button>
                </div>
            );

            return renderGame();
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
