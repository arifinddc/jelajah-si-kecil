<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Jelajah Si Kecil - Beta v1.6</title>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap');
        
        body, html { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; font-family: 'Fredoka', sans-serif; background: #0F172A; -webkit-tap-highlight-color: transparent; }
        #root { height: 100%; width: 100%; }

        .app-container {
            position: absolute; inset: 0; height: 100dvh; display: flex; flex-direction: column;
            background: linear-gradient(180deg, #1E293B 0%, #0F172A 100%);
            max-width: 500px; margin: 0 auto; border-left: 2px solid #F59E0B; border-right: 2px solid #F59E0B;
            padding-top: env(safe-area-inset-top); padding-bottom: env(safe-area-inset-bottom);
        }

        .hud-bar { height: 60px; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; padding: 0 1rem; background: rgba(15, 23, 42, 0.95); border-bottom: 3px solid #F59E0B; z-index: 20; }
        .game-area { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding: 1rem; width: 100%; overflow-y: auto; }
        .instruction-text { font-size: 1.1rem; font-weight: 700; color: #F1F5F9; margin-bottom: 0.5rem; text-align: center; }

        /* --- STYLES FOR FEATURES --- */
        .stat-badge { background: #334155; padding: 6px 12px; border-radius: 20px; font-size: 0.75rem; color: #e2e8f0; font-weight: bold; border: 1px solid #475569; transition: all 0.2s; }
        .stat-badge:active { transform: scale(0.95); background: #475569; }
        
        .reward-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; width: 100%; padding: 10px; }
        .reward-slot { aspect-ratio: 1; background: #1e293b; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 1.8rem; border: 2px solid #334155; position: relative; }
        .reward-slot.unlocked { background: #F59E0B; border-color: #fbbf24; box-shadow: 0 0 15px rgba(245, 158, 11, 0.3); animation: popIn 0.3s; }
        .reward-slot.locked { opacity: 0.5; }

        /* --- GAME SPECIFIC STYLES --- */
        /* Maze */
        .maze-grid { display: grid; gap: 4px; background: #1E293B; padding: 6px; border-radius: 16px; border: 3px solid #475569; margin-bottom: 1rem; transition: all 0.3s; }
        .maze-cell { width: 45px; height: 45px; background: #0F172A; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 1.4rem; color: #64748B; font-weight: bold; border: 1px solid #334155; position: relative; }
        .grid-4x4 .maze-cell { width: 40px; height: 40px; font-size: 1.2rem; }
        .grid-5x5 .maze-cell { width: 34px; height: 34px; font-size: 1rem; }
        .maze-cell.start { background: #F59E0B; color: white; border-color: #B45309; box-shadow: inset 0 0 10px rgba(0,0,0,0.2); z-index: 10; }

        /* Block */
        .block-target-grid { display: grid; gap: 3px; background: #1e293b; padding: 5px; border-radius: 12px; border: 3px solid #475569; margin-bottom: 20px; transition: all 0.3s; }
        .block-target-cell { width: 45px; height: 45px; border-radius: 6px; }
        .block-target-cell.filled { border: 1px solid rgba(255,255,255,0.2); }
        .block-target-cell.locked { background: #475569; border: 1px solid #334155; opacity: 0.4; } 
        .block-target-cell.hole { background: #0F172A; border: 2px dashed #475569; box-shadow: inset 0 0 5px black; }
        .mini-grid { display: grid; gap: 2px; pointer-events: none; transition: transform 0.3s; }
        .mini-cell { width: 14px; height: 14px; border-radius: 2px; }
        .mini-cell.active { background: #F59E0B; box-shadow: inset 0 0 2px rgba(255,255,255,0.5); }
        .mini-cell.empty { background: transparent; }

        /* Memory */
        .memory-shelf { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; background: #1e293b; padding: 20px; border-radius: 16px; border: 3px solid #475569; margin-bottom: 10px; min-height: 150px; width: 100%; max-width: 320px; }
        .memory-item { width: 60px; height: 60px; background: #0F172A; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 2.5rem; animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .timer-bar-container { width: 100%; max-width: 320px; height: 8px; background: #334155; border-radius: 4px; overflow: hidden; margin-bottom: 20px; }
        .timer-bar-fill { height: 100%; background: #F59E0B; transition: width linear; }

        /* Secret Code */
        .code-legend { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; margin-bottom: 15px; background: #334155; padding: 10px; border-radius: 12px; border: 2px solid #64748b; }
        .legend-item { display: flex; flex-direction: column; align-items: center; background: #0F172A; padding: 5px 10px; border-radius: 8px; border: 1px solid #475569; }
        .legend-icon { font-size: 1.5rem; }
        .legend-val { font-size: 1.2rem; font-weight: bold; color: #F59E0B; border-top: 1px solid #334155; width: 100%; text-align: center; }
        .code-question-box { display: flex; gap: 10px; align-items: center; justify-content: center; background: #1e293b; padding: 15px; border-radius: 16px; border: 3px solid #F59E0B; margin-bottom: 20px; }
        .question-icon { font-size: 3rem; animation: bounce 2s infinite; }

        /* Analysis */
        .analysis-grid { display: grid; gap: 10px; width: 100%; max-width: 320px; justify-content: center; }
        .analysis-btn { background: #334155; border: 2px solid #475569; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 2.5rem; aspect-ratio: 1; transition: transform 0.1s; box-shadow: 0 4px 0 #1e293b; }
        .analysis-btn:active { transform: scale(0.95); box-shadow: 0 1px 0 #1e293b; }
        .analysis-btn.wrong-anim { animation: shake 0.3s; background: #EF4444; border-color: #991B1B; }
        .analysis-btn.correct-anim { background: #4ADE80; border-color: #166534; box-shadow: 0 4px 0 #166534; animation: popIn 0.3s; }

        /* Pattern (Kereta Logika) */
        .pattern-train { display: flex; gap: 8px; justify-content: center; background: #334155; padding: 15px; border-radius: 16px; border: 3px solid #64748b; margin-bottom: 20px; max-width: 100%; overflow-x: auto; }
        .pattern-cell { width: 50px; height: 50px; background: #0F172A; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 1.8rem; border: 2px solid #475569; box-shadow: inset 0 0 10px rgba(0,0,0,0.3); }
        .pattern-cell.question { border: 2px dashed #F59E0B; color: #F59E0B; animation: pulse 1.5s infinite; }

        /* UI Common */
        .option-grid { display: grid; gap: 10px; width: 100%; max-width: 360px; margin-top: auto; }
        .grid-cols-2 { grid-template-columns: repeat(2, 1fr); }
        .grid-cols-3 { grid-template-columns: repeat(3, 1fr); }
        
        .btn-choice { background: white; border: 3px solid #CBD5E1; border-radius: 1rem; aspect-ratio: 1.3; display: flex; align-items: center; justify-content: center; font-size: 2rem; transition: transform 0.1s; box-shadow: 0 4px 0 #94A3B8; color: #0F172A; width: 100%; position: relative; overflow: hidden; }
        .btn-choice:active { transform: scale(0.95); box-shadow: 0 1px 0 #94A3B8; }
        .btn-choice.correct { background: #4ADE80; border-color: #166534; box-shadow: 0 4px 0 #166534; }
        .btn-choice.wrong { background: #F87171; border-color: #991B1B; box-shadow: 0 4px 0 #991B1B; opacity: 0.8; animation: shake 0.3s; }
        
        /* CARD STYLES */
        .game-card { 
            background: linear-gradient(135deg, #334155 0%, #1e293b 100%); 
            border-radius: 16px; padding: 16px 20px; margin-bottom: 12px; width: 100%; 
            border: 2px solid #475569; box-shadow: 0 4px 0 #1e293b; 
            display: flex; justify-content: space-between; align-items: center; 
            position: relative; overflow: hidden; 
            cursor: pointer; transition: transform 0.1s, box-shadow 0.1s;
        }
        .game-card:active { transform: scale(0.98); box-shadow: 0 2px 0 #1e293b; border-color: #F59E0B; }
        .game-card-title { font-size: 1.3rem; font-weight: bold; color: white; display: flex; flex-direction: column; }
        
        .menu-btn { 
            flex: 1; background: linear-gradient(180deg, #F59E0B 0%, #D97706 100%);
            color: white; padding: 12px; border-radius: 10px; font-size: 0.9rem; font-weight: bold; 
            box-shadow: 0 4px 0 #B45309; text-align: center; border: 1px solid #F59E0B;
            transition: all 0.1s; cursor: pointer;
        }
        .menu-btn:active { transform: translateY(3px); box-shadow: 0 1px 0 #B45309; }
        
        .menu-btn.secondary { background: linear-gradient(180deg, #475569 0%, #334155 100%); box-shadow: 0 4px 0 #1e293b; border: 1px solid #475569; }
        .menu-btn.daily { background: linear-gradient(135deg, #8B5CF6, #EC4899); box-shadow: 0 4px 0 #7C3AED; border: none; }
        .menu-btn.daily.completed { background: #10B981; box-shadow: 0 4px 0 #059669; cursor: default; }
        
        .home-icon-btn { background: #334155; padding: 4px 8px; border-radius: 8px; font-size: 10px; font-weight: bold; color: #F59E0B; border: 1px solid #475569; }

        /* RADAR CHART HEXAGON */
        .radar-chart-container { position: relative; width: 220px; height: 200px; margin: 20px auto; }
        .radar-label { position: absolute; font-size: 9px; font-weight: bold; color: white; text-transform: uppercase; text-shadow: 0 1px 2px black; }
        
        /* 6 Points HEXAGON */
        .radar-label.p1 { top: -15px; left: 50%; transform: translateX(-50%); } /* Top */
        .radar-label.p2 { top: 20%; right: -25px; } /* Top Right */
        .radar-label.p3 { bottom: 20%; right: -25px; } /* Bottom Right */
        .radar-label.p4 { bottom: -15px; left: 50%; transform: translateX(-50%); } /* Bottom */
        .radar-label.p5 { bottom: 20%; left: -25px; } /* Bottom Left */
        .radar-label.p6 { top: 20%; left: -25px; } /* Top Left */

        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        @keyframes popIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // --- DATA & ASSETS ---
        const BLOCK_PATTERNS = ['linear-gradient(135deg, #3B82F6, #2563EB)', 'linear-gradient(135deg, #EF4444, #DC2626)', 'linear-gradient(135deg, #10B981, #059669)', 'linear-gradient(135deg, #F59E0B, #D97706)', 'linear-gradient(135deg, #8B5CF6, #7C3AED)'];
        const MEMORY_EMOJIS = ["üê±", "üê∂", "ü¶Å", "üê∏", "üêµ", "üçé", "üçå", "üçá", "üçâ", "üçì", "üöó", "üöÄ", "‚öΩ", "üèÄ", "üçï", "üçî", "üç¶", "üéà", "üéÅ", "‚è∞"];
        const CODE_EMOJIS = ["üçé", "üçå", "üçá", "üçâ", "üçí", "ü•ù", "üçç", "ü••"];
        const CODE_VALS = ["A", "B", "C", "D", "1", "2", "3", "4"];
        const ANALYSIS_EMOJIS = ["üòÄ", "üòé", "üöÄ", "üê±", "üê∂", "üçé", "‚öΩ", "üöó"]; 
        const PATTERN_EMOJIS = ["üî¥","üîµ","üü¢","üü°","üüß","üî∫","‚≠ê","üî∑"];
        const GEOMETRY_EMOJIS = ["üî∫", "üü•", "‚¨†", "‚¨°"]; // 3, 4, 5, 6 sides
        const REWARD_ITEMS = ["üß∏", "üöÇ", "üöì", "ü¶ñ", "ü¶Ñ", "üé∏", "‚åö", "üî≠", "üè∞", "ü™Å", "üíé", "üëë"];

        const SKILL_NAMES = { maze: 'Navigasi', block: 'Spasial', memory: 'Memori', secret: 'Logika', analysis: 'Analisis', pattern: 'Pola' };

        // --- AUDIO ENGINE ---
        const playSound = (type) => {
            if (!window.AudioContext && !window.webkitAudioContext) return;
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain); gain.connect(ctx.destination);
            
            if (type === 'correct') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(523.25, ctx.currentTime); 
                osc.frequency.exponentialRampToValueAtTime(880, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
                osc.start(); osc.stop(ctx.currentTime + 0.4);
            } else if (type === 'wrong') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, ctx.currentTime); 
                osc.frequency.linearRampToValueAtTime(100, ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.2, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                osc.start(); osc.stop(ctx.currentTime + 0.3);
            } else if (type === 'unlock') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(440, ctx.currentTime);
                osc.frequency.setValueAtTime(554, ctx.currentTime + 0.1);
                osc.frequency.setValueAtTime(659, ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.2, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.01, ctx.currentTime + 0.6);
                osc.start(); osc.stop(ctx.currentTime + 0.6);
            }
        };

        const App = () => {
            const [screen, setScreen] = useState('menu'); 
            const [activeGame, setActiveGame] = useState(null);
            
            const [userData, setUserData] = useState(() => {
                const saved = localStorage.getItem('jelajah_beta_v1_6');
                const defaultData = { 
                    lives: 3, lastLifeLost: null, stars: 0,
                    unlockedRewards: [], 
                    dailyChallenge: { lastPlayed: null }, 
                    stats: { maze:{w:0,l:0}, block:{w:0,l:0}, memory:{w:0,l:0}, secret:{w:0,l:0}, analysis:{w:0,l:0}, pattern:{w:0,l:0} },
                    maze: { level: 0, score: 0 }, block: { level: 0, score: 0 },
                    memory: { level: 0, score: 0 }, secret: { level: 0, score: 0 }, analysis: { level: 0, score: 0 }, pattern: { level: 0, score: 0 }
                };
                if (saved) {
                    const parsed = JSON.parse(saved);
                    if(!parsed.pattern) parsed.pattern = { level: 0, score: 0 };
                    if(!parsed.stats.pattern) parsed.stats.pattern = { w:0, l:0 };
                    return { ...defaultData, ...parsed };
                }
                return defaultData;
            });

            const [puzzle, setPuzzle] = useState(null);
            const [feedback, setFeedback] = useState(null);
            const [wrongId, setWrongId] = useState(null);
            const [regenTimer, setRegenTimer] = useState("");
            const [memTimer, setMemTimer] = useState(100); 

            useEffect(() => { localStorage.setItem('jelajah_beta_v1_6', JSON.stringify(userData)); }, [userData]);

            // Lives Regen
            useEffect(() => {
                const timer = setInterval(() => {
                    if (userData.lives < 3 && userData.lastLifeLost) {
                        const diff = Date.now() - userData.lastLifeLost;
                        if (diff >= 600000) setUserData(p => ({ ...p, lives: Math.min(p.lives + 1, 3), lastLifeLost: p.lives+1<3?Date.now():null }));
                        else setRegenTimer(`${Math.floor((600000-diff)/60000)}:${Math.floor(((600000-diff)%60000)/1000).toString().padStart(2,'0')}`);
                    } else setRegenTimer("");
                }, 1000);
                return () => clearInterval(timer);
            }, [userData]);

            // Memory Timer
            useEffect(() => {
                if (activeGame === 'memory' && puzzle && puzzle.phase === 'memorize') {
                    const duration = puzzle.duration * 1000;
                    const interval = 50; 
                    const step = 100 / (duration / interval);
                    const t = setInterval(() => {
                        setMemTimer(prev => {
                            if (prev <= 0) {
                                clearInterval(t);
                                setPuzzle(p => ({ ...p, phase: 'question', instruction: "Mana benda yang tadi ada?" }));
                                return 0;
                            }
                            return prev - step;
                        });
                    }, interval);
                    return () => clearInterval(t);
                }
            }, [puzzle, activeGame]);

            // Helpers
            const rotateMatrix = (matrix) => {
                const rows = matrix.length; const cols = matrix[0].length;
                let newMatrix = Array.from({ length: cols }, () => Array(rows).fill(0));
                for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) newMatrix[c][rows - 1 - r] = matrix[r][c];
                return newMatrix;
            };

            const isDailyDone = () => {
                const today = new Date().toDateString();
                return userData.dailyChallenge.lastPlayed === today;
            };

            // --- GENERATORS ---
            const generateMaze = (customLevel = null) => {
                const level = customLevel !== null ? customLevel : userData.maze.level;
                let gridSize = 3; let steps = 2; let optionCount = 2;
                if (level >= 5) { gridSize = 3; steps = 3; optionCount = 3; }
                if (level >= 10) { gridSize = 4; steps = 3; optionCount = 4; }
                if (level >= 20) { gridSize = 4; steps = 4; optionCount = 4; }
                if (level >= 30) { gridSize = 5; steps = 5; optionCount = 6; }
                const totalCells = gridSize * gridSize;
                const labels = "ABCDEFGHIJKLMNOPQRSTUVWXY".split("").slice(0, totalCells);
                const startPos = Math.floor(Math.random() * totalCells);
                let currentPos = startPos; let pathHistory = [startPos]; let arrowSequence = [];
                for (let i = 0; i < steps; i++) {
                    let possibleMoves = [];
                    if ((currentPos + 1) % gridSize !== 0 && pathHistory[pathHistory.length-2] !== currentPos + 1) possibleMoves.push({ move: 1, icon: '‚û°Ô∏è' });
                    if (currentPos + gridSize < totalCells && pathHistory[pathHistory.length-2] !== currentPos + gridSize) possibleMoves.push({ move: gridSize, icon: '‚¨áÔ∏è' });
                    if (currentPos % gridSize !== 0 && pathHistory[pathHistory.length-2] !== currentPos - 1) possibleMoves.push({ move: -1, icon: '‚¨ÖÔ∏è' });
                    if (currentPos - gridSize >= 0 && pathHistory[pathHistory.length-2] !== currentPos - gridSize) possibleMoves.push({ move: -gridSize, icon: '‚¨ÜÔ∏è' });
                    if (possibleMoves.length === 0) break;
                    const selected = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    currentPos += selected.move; pathHistory.push(currentPos); arrowSequence.push(selected.icon);
                }
                const targetLabel = labels[currentPos];
                const targetOption = { id: `pos_${currentPos}`, icon: targetLabel, isTarget: true };
                const otherIndices = Array.from({length: totalCells}, (_, i) => i).filter(i => i !== currentPos);
                const randomWrong = otherIndices.sort(() => 0.5 - Math.random()).slice(0, optionCount - 1);
                const wrongOptions = randomWrong.map(idx => ({ id: `pos_${idx}`, icon: labels[idx], isTarget: false }));
                setPuzzle({ gameType: 'maze', gridSize, labels, arrows: arrowSequence, options: [targetOption, ...wrongOptions].sort(() => 0.5 - Math.random()), targetId: targetOption.id, startIndex: startPos, instruction: "Ikuti panah! Dimana Kucing sekarang?" });
            };

            const generateBlock = (customLevel = null) => {
                const level = customLevel !== null ? customLevel : userData.block.level;
                let gridSize = 3; let missingCount = 2; let isScattered = false; let optionCount = 2; let lockedCount = 0; let isRotationActive = false;
                if (level >= 5) { gridSize = 4; missingCount = 3; lockedCount = 1; optionCount = 3; }
                if (level >= 10) { gridSize = 4; missingCount = 3; lockedCount = 2; optionCount = 4; isScattered = true; isRotationActive = true; }
                if (level >= 25) { gridSize = 4; missingCount = 4; lockedCount = 3; optionCount = 4; isScattered = true; isRotationActive = true; }
                const totalCells = gridSize * gridSize;
                const mainPattern = BLOCK_PATTERNS[Math.floor(Math.random() * BLOCK_PATTERNS.length)];
                let missingIndices = []; let startIdx = Math.floor(Math.random() * totalCells); missingIndices.push(startIdx);
                while(missingIndices.length < missingCount) {
                    if (isScattered) {
                        let nextIdx = Math.floor(Math.random() * totalCells); if (!missingIndices.includes(nextIdx)) missingIndices.push(nextIdx);
                    } else {
                        let lastIdx = missingIndices[missingIndices.length-1]; let neighbors = [];
                        if ((lastIdx + 1) % gridSize !== 0) neighbors.push(lastIdx + 1);
                        if (lastIdx % gridSize !== 0) neighbors.push(lastIdx - 1);
                        if (lastIdx + gridSize < totalCells) neighbors.push(lastIdx + gridSize);
                        if (lastIdx - gridSize >= 0) neighbors.push(lastIdx - gridSize);
                        if(neighbors.length === 0) break;
                        let nextIdx = neighbors[Math.floor(Math.random() * neighbors.length)];
                        if (!missingIndices.includes(nextIdx)) missingIndices.push(nextIdx);
                    }
                }
                missingIndices.sort((a,b) => a-b);
                let lockedIndices = []; let safeIndices = Array.from({length: totalCells}, (_,i) => i).filter(i => !missingIndices.includes(i));
                for(let i=0; i<lockedCount; i++){ if (safeIndices.length === 0) break; let pick = Math.floor(Math.random() * safeIndices.length); lockedIndices.push(safeIndices[pick]); safeIndices.splice(pick, 1); }
                let gridState = Array(totalCells).fill('filled'); missingIndices.forEach(i => gridState[i] = 'hole'); lockedIndices.forEach(i => gridState[i] = 'locked');
                const targetOption = { id: 'correct', indices: [...missingIndices], isTarget: true, isRotated: false };
                if (isRotationActive && Math.random() > 0.4) targetOption.isRotated = true;
                const wrongOpts = [];
                for (let i=0; i < optionCount - 1; i++) {
                    let fakeIndices = [...missingIndices];
                    if (Math.random() > 0.5 && fakeIndices.length > 0) fakeIndices[0] = (fakeIndices[0] + 1) % totalCells;
                    else { if (fakeIndices.length > 1) fakeIndices.pop(); else { let r = Math.floor(Math.random() * totalCells); if (!fakeIndices.includes(r)) fakeIndices.push(r); } }
                    wrongOpts.push({ id: `wrong_${i}`, indices: fakeIndices, isTarget: false, isRotated: isRotationActive && Math.random() > 0.5 });
                }
                setPuzzle({ gameType: 'block', gridSize, gridState, gridPattern: mainPattern, options: [targetOption, ...wrongOpts].sort(() => 0.5 - Math.random()), targetId: 'correct', instruction: isRotationActive ? "Pasang blok! (Bisa diputar)" : "Pasang blok yang cocok!" });
            };

            const generateMemory = (customLevel = null) => {
                const level = customLevel !== null ? customLevel : userData.memory.level;
                let itemCount = 3; let duration = 4; let optionCount = 2;
                if (level >= 5) { itemCount = 4; duration = 4; optionCount = 3; }
                if (level >= 15) { itemCount = 5; duration = 3; optionCount = 4; }
                if (level >= 25) { itemCount = 6; duration = 3; optionCount = 4; }
                const shuffledPool = [...MEMORY_EMOJIS].sort(() => 0.5 - Math.random());
                const shownItems = shuffledPool.slice(0, itemCount);
                const targetItem = shownItems[Math.floor(Math.random() * shownItems.length)];
                const notShown = shuffledPool.slice(itemCount); const distractors = notShown.slice(0, optionCount - 1);
                const options = [{ id: 'correct', icon: targetItem, isTarget: true }, ...distractors.map((item, i) => ({ id: `wrong_${i}`, icon: item, isTarget: false }))];
                setMemTimer(100);
                setPuzzle({ gameType: 'memory', phase: 'memorize', items: shownItems, duration: duration, options: options.sort(() => 0.5 - Math.random()), targetId: 'correct', instruction: "Hafalkan benda ini!" });
            };

            const generateSecret = (customLevel = null) => {
                const level = customLevel !== null ? customLevel : userData.secret.level;
                let pairCount = 3; let qLength = 2; let optionCount = 2;
                if (level >= 5) { pairCount = 4; qLength = 3; optionCount = 3; }
                if (level >= 15) { pairCount = 5; qLength = 3; optionCount = 4; }
                if (level >= 25) { pairCount = 5; qLength = 4; optionCount = 4; }
                const shuffledIcons = [...CODE_EMOJIS].sort(()=>0.5-Math.random()).slice(0, pairCount);
                const shuffledVals = [...CODE_VALS].sort(()=>0.5-Math.random()).slice(0, pairCount);
                let legend = []; for(let i=0; i<pairCount; i++) legend.push({ icon: shuffledIcons[i], val: shuffledVals[i] });
                let questionIcons = []; let answerStr = "";
                for(let i=0; i<qLength; i++){ const pick = legend[Math.floor(Math.random() * legend.length)]; questionIcons.push(pick.icon); answerStr += pick.val; }
                const targetOption = { id: 'correct', text: answerStr, isTarget: true };
                const wrongOpts = [];
                for(let i=0; i<optionCount-1; i++){
                    let fakeStr = "";
                    if(Math.random() > 0.5) { fakeStr = answerStr.split('').sort(()=>0.5-Math.random()).join(''); if (fakeStr === answerStr) fakeStr = answerStr.split('').reverse().join(''); } 
                    else { for(let k=0; k<qLength; k++) fakeStr += legend[Math.floor(Math.random()*legend.length)].val; }
                    if(fakeStr === answerStr) fakeStr += "X"; 
                    wrongOpts.push({ id: `wrong_${i}`, text: fakeStr, isTarget: false });
                }
                setPuzzle({ gameType: 'secret', legend, question: questionIcons, options: [targetOption, ...wrongOpts].sort(()=>0.5-Math.random()), targetId: 'correct', instruction: "Terjemahkan kodenya!" });
            };

            const generateAnalysis = (customLevel = null) => {
                const level = customLevel !== null ? customLevel : userData.analysis.level;
                let gridSize = 2; // 2x2 = 4 items
                if (level >= 5) gridSize = 3; // 3x3 = 9 items
                const totalItems = gridSize * gridSize;
                const baseIcon = ANALYSIS_EMOJIS[Math.floor(Math.random() * ANALYSIS_EMOJIS.length)];
                
                let targetIcon = baseIcon;
                let isRotationDiff = false;
                let isColorDiff = false;

                if (level < 5) {
                    let otherIcons = ANALYSIS_EMOJIS.filter(e => e !== baseIcon);
                    targetIcon = otherIcons[Math.floor(Math.random() * otherIcons.length)];
                } else if (level < 15) {
                    isRotationDiff = true;
                } else {
                    isColorDiff = true;
                }

                const targetIdx = Math.floor(Math.random() * totalItems);
                const options = [];
                for(let i=0; i<totalItems; i++) {
                    const isTarget = (i === targetIdx);
                    options.push({
                        id: i, icon: isTarget ? targetIcon : baseIcon, isTarget: isTarget,
                        style: isTarget ? { transform: isRotationDiff ? 'rotate(90deg)' : 'none', filter: isColorDiff ? 'hue-rotate(90deg)' : 'none' } : {}
                    });
                }
                setPuzzle({ gameType: 'analysis', gridSize, options, targetId: targetIdx, instruction: "Mana yang beda?" });
            };

            const generatePattern = (customLevel = null) => {
                const level = customLevel !== null ? customLevel : userData.pattern.level;
                let difficulty = 1; // 1: AB, 2: ABC/AAB, 3: Num, 4: Geom
                
                if (level >= 5) difficulty = 2;
                if (level >= 15) difficulty = 3;
                if (level >= 25) difficulty = 4;

                let sequence = [];
                let target = "";
                let options = [];

                if (difficulty === 1) { // AB-AB
                    const a = PATTERN_EMOJIS[Math.floor(Math.random()*PATTERN_EMOJIS.length)];
                    let b = PATTERN_EMOJIS[Math.floor(Math.random()*PATTERN_EMOJIS.length)];
                    while(b===a) b = PATTERN_EMOJIS[Math.floor(Math.random()*PATTERN_EMOJIS.length)];
                    sequence = [a, b, a, b, a];
                    target = b;
                    options = [b, a, PATTERN_EMOJIS[Math.floor(Math.random()*PATTERN_EMOJIS.length)]];
                } else if (difficulty === 2) { // ABC or AAB
                    const type = Math.random() > 0.5 ? 'ABC' : 'AAB';
                    const a = PATTERN_EMOJIS[Math.floor(Math.random()*PATTERN_EMOJIS.length)];
                    let b = PATTERN_EMOJIS[Math.floor(Math.random()*PATTERN_EMOJIS.length)];
                    while(b===a) b = PATTERN_EMOJIS[Math.floor(Math.random()*PATTERN_EMOJIS.length)];
                    let c = PATTERN_EMOJIS[Math.floor(Math.random()*PATTERN_EMOJIS.length)];
                    while(c===a || c===b) c = PATTERN_EMOJIS[Math.floor(Math.random()*PATTERN_EMOJIS.length)];

                    if(type === 'ABC') { sequence = [a,b,c,a,b]; target = c; options=[c, a, b]; }
                    else { sequence = [a,a,b,a,a]; target = b; options=[b, a, c]; }
                } else if (difficulty === 3) { // Numbers
                    const start = Math.floor(Math.random() * 5) + 1;
                    const step = Math.floor(Math.random() * 3) + 1;
                    sequence = [start, start+step, start+step*2, start+step*3, start+step*4];
                    target = start+step*5;
                    options = [target, target-1, target+2];
                } else { // Geometry (Sides)
                    // 3, 4, 5 -> 6
                    sequence = [GEOMETRY_EMOJIS[0], GEOMETRY_EMOJIS[1], GEOMETRY_EMOJIS[2]];
                    target = GEOMETRY_EMOJIS[3];
                    options = [GEOMETRY_EMOJIS[3], GEOMETRY_EMOJIS[0], GEOMETRY_EMOJIS[1]];
                }
                
                // Shuffle options
                const finalOptions = options.map((val, i) => ({
                    id: `opt_${i}`,
                    icon: val,
                    isTarget: val === target
                })).sort(() => 0.5 - Math.random());

                setPuzzle({
                    gameType: 'pattern',
                    sequence: sequence,
                    options: finalOptions,
                    targetId: 'dummy', // Not used directly logic handled in loop
                    instruction: "Lengkapi keretanya!"
                });
            };

            // --- CONTROLLERS ---
            const startGame = (type, mode) => {
                setActiveGame(type);
                if (mode === 'new') setUserData(p => ({ ...p, lives: 3, [type]: { level: 0, score: 0 } }));
                setScreen('game');
                setTimeout(() => {
                    const lv = userData[type].level;
                    switch(type) {
                        case 'maze': generateMaze(lv); break;
                        case 'block': generateBlock(lv); break;
                        case 'memory': generateMemory(lv); break;
                        case 'secret': generateSecret(lv); break;
                        case 'analysis': generateAnalysis(lv); break;
                        case 'pattern': generatePattern(lv); break;
                    }
                }, 50);
            };

            const startDailyChallenge = () => {
                if (isDailyDone()) return;
                setActiveGame('daily');
                setScreen('game');
                const games = ['maze', 'block', 'memory', 'secret', 'analysis', 'pattern'];
                const randomType = games[Math.floor(Math.random() * games.length)];
                
                setTimeout(() => {
                    const diff = 15;
                    switch(randomType) {
                        case 'maze': generateMaze(diff); break;
                        case 'block': generateBlock(diff); break;
                        case 'memory': generateMemory(diff); break;
                        case 'secret': generateSecret(diff); break;
                        case 'analysis': generateAnalysis(diff); break;
                        case 'pattern': generatePattern(diff); break;
                    }
                }, 50);
            };

            const nextLevel = () => {
                if(activeGame === 'daily') { setScreen('menu'); return; }
                switch(activeGame) {
                    case 'maze': generateMaze(); break;
                    case 'block': generateBlock(); break;
                    case 'memory': generateMemory(); break;
                    case 'secret': generateSecret(); break;
                    case 'analysis': generateAnalysis(); break;
                    case 'pattern': generatePattern(); break;
                }
            };

            const handleAnswer = (opt) => {
                if (feedback === 'correct') return;
                if (opt.isTarget) {
                    playSound('correct'); setFeedback('correct'); setWrongId(null);
                    setTimeout(() => {
                        if(activeGame === 'daily') {
                            const today = new Date().toDateString();
                            setUserData(p => ({ ...p, stars: p.stars + 50, dailyChallenge: { lastPlayed: today } }));
                            setScreen('result_daily');
                        } else {
                            setUserData(p => ({
                                ...p, stars: p.stars + 10,
                                stats: { ...p.stats, [activeGame]: { ...p.stats[activeGame], w: p.stats[activeGame].w + 1 } },
                                [activeGame]: { level: p[activeGame].level + 1, score: p[activeGame].score + 10 }
                            }));
                            setScreen('result');
                        }
                        setFeedback(null);
                    }, 500);
                } else {
                    playSound('wrong'); setWrongId(opt.id);
                    if (activeGame !== 'daily') {
                        setUserData(p => ({ 
                            ...p, lives: Math.max(0, p.lives-1), 
                            stats: { ...p.stats, [activeGame]: { ...p.stats[activeGame], l: p.stats[activeGame].l + 1 } },
                            lastLifeLost: p.lives===3?Date.now():p.lastLifeLost 
                        }));
                    }
                    setTimeout(() => setWrongId(null), 500);
                }
            };

            const unlockReward = (index) => {
                if (userData.stars >= 50 && !userData.unlockedRewards.includes(index)) {
                    playSound('unlock');
                    setUserData(p => ({ ...p, stars: p.stars - 50, unlockedRewards: [...p.unlockedRewards, index] }));
                }
            };

            // --- RENDER HELPERS ---
            const renderOptionGrid = (indices, gridSize, pattern, isRotated) => {
                let matrix = Array.from({length: gridSize}, () => Array(gridSize).fill(0));
                indices.forEach(idx => {
                    const r = Math.floor(idx / gridSize); const c = idx % gridSize;
                    if(r < gridSize && c < gridSize) matrix[r][c] = 1;
                });
                if (isRotated) matrix = rotateMatrix(matrix);
                return (
                    <div className="mini-grid" style={{gridTemplateColumns: `repeat(${gridSize}, 1fr)`}}>
                        {matrix.flat().map((val, i) => (
                            <div key={i} className={`mini-cell ${val===1 ? 'active' : 'empty'}`} style={{background: val===1 ? pattern : 'transparent'}}></div>
                        ))}
                    </div>
                );
            };

            const RadarChart = () => {
                const stats = userData.stats;
                const getWinRate = (key) => {
                    const s = stats[key]; const total = s.w + s.l;
                    return total === 0 ? 0 : (s.w / total);
                };
                const rates = [getWinRate('maze'), getWinRate('block'), getWinRate('memory'), getWinRate('secret'), getWinRate('analysis'), getWinRate('pattern')];
                // 6 Angles: -90, -30, 30, 90, 150, 210
                const angles = [-90, -30, 30, 90, 150, 210];
                const center = 110; const radius = 80;
                const points = angles.map((angle, i) => {
                    const r = radius * rates[i];
                    const rad = angle * (Math.PI / 180);
                    return `${center + r * Math.cos(rad)},${100 + r * Math.sin(rad)}`;
                }).join(" ");
                return (
                    <div className="radar-chart-container">
                        <span className="radar-label p1">Navigasi</span>
                        <span className="radar-label p2">Spasial</span>
                        <span className="radar-label p3">Memori</span>
                        <span className="radar-label p4">Logika</span>
                        <span className="radar-label p5">Analisis</span>
                        <span className="radar-label p6">Pola</span>
                        <svg width="220" height="200" viewBox="0 0 220 200" style={{background:'#1e293b', borderRadius:'50%'}}>
                            {[20, 40, 60, 80].map(r => {
                                const pts = angles.map(a => { const rad = a * (Math.PI / 180); return `${center + r * Math.cos(rad)},${100 + r * Math.sin(rad)}`; }).join(" ");
                                return <polygon key={r} points={pts} fill="none" stroke="#334155" strokeWidth="1"/>
                            })}
                            {angles.map((a, i) => { const rad = a * (Math.PI / 180); return <line key={i} x1={center} y1={100} x2={center + 80*Math.cos(rad)} y2={100 + 80*Math.sin(rad)} stroke="#334155" /> })}
                            <polygon points={points} fill="rgba(245, 158, 11, 0.5)" stroke="#F59E0B" strokeWidth="2" />
                        </svg>
                    </div>
                );
            };

            // --- SCREENS ---
            if (screen === 'menu') return (
                <div className="app-container p-4 overflow-y-auto">
                    <div className="text-center mt-2 mb-6">
                        <h1 className="text-2xl font-black text-white uppercase tracking-tight">Jelajah Si Kecil</h1>
                        <p className="text-amber-500 font-bold text-[10px] uppercase tracking-widest mb-4">Beta v1.6</p>
                        <div className="flex justify-center gap-3">
                            <button onClick={()=>setScreen('dashboard')} className="stat-badge">üìä Progress</button>
                            <button onClick={()=>setScreen('collection')} className="stat-badge">üéÅ Koleksi</button>
                        </div>
                    </div>

                    <div className="mb-4">
                        <button onClick={startDailyChallenge} disabled={isDailyDone()} 
                             className={`menu-btn daily w-full text-white ${isDailyDone() ? 'completed' : 'animate-pulse'}`}>
                             {isDailyDone() ? '‚úÖ TANTANGAN SELESAI' : '‚ö° TANTANGAN HARIAN (50‚≠ê)'}
                        </button>
                    </div>

                    {['maze', 'block', 'memory', 'secret', 'analysis', 'pattern'].map(game => (
                        <div key={game} onClick={() => startGame(game, 'continue')} className="game-card">
                            <div className="game-card-title">
                                <span>{SKILL_NAMES[game]}</span>
                                <span className="text-[10px] text-slate-400 font-normal">Lv {userData[game].level + 1}</span>
                            </div>
                            <div className="text-2xl text-amber-500 animate-pulse">‚ñ∂</div>
                        </div>
                    ))}
                    
                    <div className="text-center text-slate-500 text-[10px] mt-4 pb-4">Energi: {userData.lives}/3 {regenTimer} ‚Ä¢ Bintang: {userData.stars}</div>
                </div>
            );

            if (screen === 'dashboard') return (
                <div className="app-container p-6">
                    <h2 className="text-xl font-bold text-white mb-2 text-center">üìä STATISTIK SKILL</h2>
                    <RadarChart />
                    <div className="grid gap-2 mt-4">
                        {['maze', 'block', 'memory', 'secret', 'analysis', 'pattern'].map(g => {
                            const stats = userData.stats[g];
                            const total = stats.w + stats.l;
                            const rate = total > 0 ? Math.round((stats.w/total)*100) : 0;
                            return (
                                <div key={g} className="bg-slate-800 p-3 rounded-lg flex justify-between items-center">
                                    <span className="text-white font-bold capitalize text-sm">{SKILL_NAMES[g]}</span>
                                    <span className="text-slate-400 text-xs">{rate}% Akurasi ({stats.w}/{total})</span>
                                </div>
                            )
                        })}
                    </div>
                    <button onClick={()=>setScreen('menu')} className="menu-btn mt-auto">KEMBALI</button>
                </div>
            );

            if (screen === 'collection') return (
                <div className="app-container p-6">
                    <div className="text-center mb-4">
                        <h2 className="text-xl font-bold text-white">üéÅ KAMAR HADIAH</h2>
                        <div className="text-amber-500 font-bold mt-2">‚≠ê {userData.stars} Bintang</div>
                        <p className="text-slate-400 text-[10px]">Kumpulkan 50 Bintang untuk membuka hadiah!</p>
                    </div>
                    <div className="reward-grid">
                        {REWARD_ITEMS.map((item, i) => {
                            const isUnlocked = userData.unlockedRewards.includes(i);
                            const canAfford = userData.stars >= 50;
                            return (
                                <button key={i} disabled={isUnlocked || !canAfford} onClick={()=>!isUnlocked && unlockReward(i)}
                                    className={`reward-slot ${isUnlocked ? 'unlocked' : 'locked'}`}>
                                    {isUnlocked ? item : (canAfford ? 'üîì' : 'üîí')}
                                </button>
                            )
                        })}
                    </div>
                    <button onClick={()=>setScreen('menu')} className="menu-btn secondary mt-auto">KEMBALI</button>
                </div>
            );

            if (screen === 'result') return (
                <div className="app-container p-6 justify-center items-center text-center bg-slate-900">
                    <div className="text-7xl mb-6 animate-bounce">üåü</div>
                    <h2 className="text-3xl font-bold text-white mb-2">HEBAT!</h2>
                    <p className="text-amber-500 font-bold mb-8">+10 Bintang</p>
                    <button onClick={() => { setScreen('game'); nextLevel(); }} className="menu-btn bg-green-600 w-full max-w-[240px] py-4 text-xl shadow-lg mb-4">LANJUT LEVEL</button>
                    <button onClick={() => setScreen('menu')} className="text-slate-500 font-bold uppercase text-xs">Ke Menu Utama</button>
                </div>
            );
            
            if (screen === 'result_daily') return (
                <div className="app-container p-6 justify-center items-center text-center bg-slate-900">
                    <div className="text-7xl mb-6 animate-bounce">‚ö°</div>
                    <h2 className="text-2xl font-bold text-white mb-2">TANTANGAN SELESAI!</h2>
                    <p className="text-amber-500 font-bold mb-8">+50 Bintang Bonus</p>
                    <button onClick={() => setScreen('menu')} className="menu-btn w-full max-w-[240px]">KEMBALI KE MENU</button>
                </div>
            );

            // GAME SCREEN
            return (
                <div className="app-container">
                    <div className="hud-bar">
                        <div className="flex flex-col items-center"><span className="text-lg">‚ù§Ô∏è {userData.lives}</span><span className="text-[8px] text-slate-400">{regenTimer}</span></div>
                        <div className="flex flex-col items-center">
                            <span className="text-[10px] text-slate-400 font-bold uppercase">{activeGame==='daily'?'Tantangan':SKILL_NAMES[activeGame]} Lv {activeGame==='daily'?'?':userData[activeGame].level + 1}</span>
                            <button onClick={() => setScreen('menu')} className="home-icon-btn mt-1">üè† MENU</button>
                        </div>
                        <div className="bg-amber-500 text-white px-3 py-1 rounded-full font-bold text-sm shadow">‚≠ê {userData.stars}</div>
                    </div>

                    <div className="game-area">
                        {userData.lives <= 0 ? (
                            <div className="text-center mt-20">
                                <div className="text-6xl mb-4">üíî</div>
                                <h2 className="text-xl text-white font-bold mb-4">Energi Habis!</h2>
                                <button onClick={() => setScreen('menu')} className="menu-btn w-full">KEMBALI KE MENU</button>
                            </div>
                        ) : puzzle ? (
                            <div className="w-full flex flex-col items-center h-full">
                                <h2 className="instruction-text">{puzzle.instruction}</h2>
                                <div className="flex-1 flex flex-col items-center justify-center w-full">
                                    {/* RENDER LOGIC */}
                                    {puzzle.gameType === 'maze' && (
                                        <>
                                            <div className="maze-arrows-box">{puzzle.arrows.map((a, i) => <span key={i}>{a}</span>)}</div>
                                            <div className={`maze-grid grid-${puzzle.gridSize}`} style={{gridTemplateColumns: `repeat(${puzzle.gridSize}, 1fr)`}}>
                                                {puzzle.labels.map((l, i) => (
                                                    <div key={i} className={`maze-cell ${i===puzzle.startIndex ? 'start' : ''} ${puzzle.gridSize===4?'text-sm':''} ${puzzle.gridSize===5?'text-xs':''}`}>{i===puzzle.startIndex ? 'üê±' : l}</div>
                                                ))}
                                            </div>
                                        </>
                                    )}
                                    {puzzle.gameType === 'block' && (
                                        <div className="block-target-grid" style={{gridTemplateColumns: `repeat(${puzzle.gridSize}, 1fr)`}}>
                                            {puzzle.gridState.map((status, i) => (
                                                <div key={i} className={`block-target-cell ${status}`} style={{background: status === 'filled' ? puzzle.gridPattern : ''}}></div>
                                            ))}
                                        </div>
                                    )}
                                    {puzzle.gameType === 'memory' && (
                                        <>
                                            {puzzle.phase === 'memorize' ? (
                                                <div className="w-full flex flex-col items-center">
                                                    <div className="memory-shelf">{puzzle.items.map((item, i) => <div key={i} className="memory-item">{item}</div>)}</div>
                                                    <div className="timer-bar-container"><div className="timer-bar-fill" style={{width: `${memTimer}%`}}></div></div>
                                                </div>
                                            ) : (
                                                <div className="memory-shelf flex items-center justify-center"><span className="text-4xl">‚ùì</span></div>
                                            )}
                                        </>
                                    )}
                                    {puzzle.gameType === 'secret' && (
                                        <div className="w-full flex flex-col items-center">
                                            <div className="code-legend">
                                                {puzzle.legend.map((l, i) => <div key={i} className="legend-item"><div className="legend-icon">{l.icon}</div><div className="legend-val">{l.val}</div></div>)}
                                            </div>
                                            <div className="code-question-box">{puzzle.question.map((q, i) => <div key={i} className="question-icon">{q}</div>)}<div className="text-4xl text-white font-bold ml-2">= ?</div></div>
                                        </div>
                                    )}
                                    {puzzle.gameType === 'analysis' && (
                                        <div className="analysis-grid" style={{gridTemplateColumns: `repeat(${puzzle.gridSize}, 1fr)`}}>
                                            {puzzle.options.map((opt, i) => (
                                                <button key={i} onClick={() => handleAnswer(opt)}
                                                    className={`analysis-btn ${feedback==='correct' && opt.isTarget ? 'correct-anim' : ''} ${wrongId === opt.id ? 'wrong-anim' : ''}`}
                                                    style={opt.style}>
                                                    {opt.icon}
                                                </button>
                                            ))}
                                        </div>
                                    )}
                                    {puzzle.gameType === 'pattern' && (
                                        <div className="w-full">
                                            <div className="pattern-train">
                                                {puzzle.sequence.map((item, i) => (
                                                    <div key={i} className="pattern-cell">{item}</div>
                                                ))}
                                                <div className="pattern-cell question">?</div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                                
                                {puzzle.gameType !== 'analysis' && !(puzzle.gameType === 'memory' && puzzle.phase === 'memorize') && (
                                    <div className={`option-grid ${puzzle.options.length > 4 ? 'grid-cols-3' : 'grid-cols-2'}`}>
                                        {puzzle.options.map((opt, i) => (
                                            <button key={i} onClick={() => handleAnswer(opt)} className={`btn-choice ${feedback==='correct' && opt.isTarget ? 'correct' : ''} ${wrongId === opt.id ? 'wrong' : ''}`}>
                                                {puzzle.gameType === 'maze' ? opt.icon : 
                                                 puzzle.gameType === 'block' ? renderOptionGrid(opt.indices, puzzle.gridSize, puzzle.gridPattern, opt.isRotated) :
                                                 puzzle.gameType === 'secret' ? <span className="text-3xl font-bold">{opt.text}</span> : opt.icon}
                                            </button>
                                        ))}
                                    </div>
                                )}
                            </div>
                        ) : <div className="text-white">Memuat...</div>}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
